+ Basic usage test (going to configure the server port)
+ Uniform configuration-supporting command registration for modules: I'm
  going to add a "commands" object to modules that will include all the
  information about the commands along with the callbacks for them. Then
  I'll link command registration to configuration loading.
+ UI for changing the configuration during runtime.
+ Configuration backup system
+ Add image floating (opposite of dropping), then add a random image pool to Catastrophe that floats up images randomly with keypresses and possible cooldown (e.g. no more than 1 image per 5 seconds).
+ Disable tab index on labels in GUI
+ Disable tab index on labels in modals
- Default sizes
+ Remove value placeholders
- Hand icon for "selecting one(s)"
- Simpler mode
+ Duration still in milliseconds in image functions
+ Module descriptions
+ Changes marked in previously-accepted modules on any change
- GUI: Hitting Enter should switch to next field
- Video assets
- Meme command that shows a random meme
- Testing =\
- Revamp configs to lessen descriptor count =\

GUI User Feedback:
+ Lables should be unmarkable, cursor should stay a pointer
- More text color to separate things from each other
- Accordions should allow only one thing open at a time
- Auto-complete user names from followers (fetch followers from Twitch)
- Hard to tell what you've done already, separate labels from folders, separate consecutive fields
- Cursor should highlight the entire row, not just the text


- Support for user data files for modules (for large data that shouldn't
  be in the configurations themselves).
- Switch to function-trigger based configuration form.
  Trigger ideas:
	+ Command (with filters)
	- Keywords (+ filters, regex)
	- Twitch events (message, action, etc.)
	+ Key shortcut
	+ Key down/up
	- Controller buttons
	- Voice command
	+ Channel Reward
	- Window de/activation
	- Window open/close
	- CLI command
	- Another function activating
- Also add function responses.
  Response ideas:
	+ Chat message
	- Whisper
	+ Chat message from SE
	- TTS
	+ Log
	- File?
- Filter ideas:
	+ Specific user
	+ One of specific users
	+ Is mod
	+ Is sub
	+ And
	+ Or
	- Window running
	- Window active
	- Complex
	- Temporary window "switch"? (something switches it on - allowed, something switches it off - disallowed)
- Trigger variants
- "Not user" filter
- Fix: single-time GIFs not starting over when shown again
- User data editor: raw (use shell to open Notepad for data files).
- User data editor: built-in, data-specific interface that allows visual
  editing of the data (each module will need to define these editors for
  itself).
- Persistent data for modules
- OBS Websocket module
- Voice activation mechanism (in addition to commands and shortcut keys)
- Make WebEntities generation clear the WebEntities dir before writing to it.
- Generate commands information page to automatically be put online for viewers to see
- ZIP configuration text files
- Duration picker GUI for time-related values

- NPM Uninstall image-size if I no longer use it
+ Mark library directories as excluded in IDE after comitting, see if it does what I think it does

IDEAS!
- Bingo game
- Chat "Meow?": deletes all messages from people that aren't made of solely meowing.


Next:
+ Filters
- Variables, help display, auto-complete variable names
	+ Make help text not close if focusing on that
+ Fix replacement with escaping so that using input text (written in a Twitch message by someone) on text replacements doesn't register as text to replace
- Switch everything to work with functions
- Phase out old code (commands, shortcuts, user filters if I do something completely different)
- Add more triggers and responses (see list above)
Then other things, probably in the following order:
- Add asset cleanup that gets rid of assets without linked configurations
	- Make that happen on configuration saves and startup
- Persistent data
- Complex data configuration (graphs for adventures, video for Channel Party, sequences for Parrot Mate)


Selected functions module setup example (what I'm acutally gonna do now):
	functions = {
		adventure: {
			name: 'Start Adventure',
			description: 'Starts the adventure by the user',
			parameters: [ // Order matters
				{
					name: 'Type', // Must be unique in the function
					description: 'The type of adventure to start (e.g. spooky, candy)',
					default: 'spooky',
					// Will have a .value filled in by the invocation
				}
			],
			callback: user => this.startRecruiting(user),
			cooldown: {
				user: 10,
				global: 5,
			},
			triggers: [
				this.trigger.command({
					cmdname: 'adventure',
					aliases: ['adv'],
					filters: [this.filterDesc('isOneOf', ['yecatsmailbox', 'fluxistence'])],
					cooldown: {
						user: 40,
						global: 20,
					},
				}),
				this.trigger.keywords({
					keywords: ['hello', 'there', /abc/],
					filters: [this.filterDesc('isOneOf', ['yecatsmailbox', 'fluxistence'])],
				}),
				this.trigger.shorctut({
					keys: [
						['BACKSPACE'], // The backspace key on the keyboard
					],
					filters: [this.filterDesc('windowActive', ['Phasmophobia', 'Spelunky 2'])],
					paramValues: [
						'candy',
					]
				}),
				this.trigger.voice({
					// ???,
					filters: [this.filterDesc('windowActive', ['Phasmophobia', 'Spelunky 2'])],
				}),
				this.trigger.channelReward({
					name: 'Catastrophe',
					filters: [this.filterDesc('isMod')],
				}),
			],
			variables: [
				this.variable.out('type', {
					name: 'Adventure Type ($type)',
					description: 'Selected category of adventures to choose from (e.g. spooky, candy)',
					example: 'Wow, what a $type that was, people, eh?',
				},
			],
			responses: [
				this.response.console('Hey, it worked!'),
				this.response.console({
					level: 'warn',
					message: 'Blame it on $user: 1: $1 2: $2 3: $3 all: $all.',
				}),
				this.response.chat({
					message: 'Hello $user, nice to see you! One $type adventure, coming up!',
				}),
				this.response.whisper({
					usernames: ['yecatsmailbox', '$user'],
					message: 'I saw you say that!',
				}),
				this.response.se({
					message: "Hi, I'm StreamElements!",
				}),
				this.response.tts({
					message: "Don't do that, $user!",
					voice: 'Brian',
				}),
				this.log({
					// Location? Category?
					message: '$user did that thing.',
				}),
				this.file({
					message: 'Yay $user!',
					path: 'C:/Path/to/file.txt',
					append: false,  // True by default
				})
			],
		},
	}





Potential functions module setup example (NOTE: all trigger variables are available as response variables automatically):
	functions = {
		adventure: {
			name: 'Start Adventure',
			description: 'Starts the adventure by the user',
			callback: user => this.startRecruiting(user),
			cooldown: {
				user: 10,
				global: 5,
			},
			triggers: [
				this.trigger.command({
					cmdname: 'adventure',
					aliases: ['adv'],
					filters: [this.filterDesc('isOneOf', ['yecatsmailbox', 'fluxistence'])],
					cooldown: {
						user: 40,
						global: 20,
					},
					parameters: ['$type'],
				}),
				this.trigger.keywords({
					keywords: ['hello', 'there', /abc/],
					filters: [this.filterDesc('isOneOf', ['yecatsmailbox', 'fluxistence'])],
				}),
				this.trigger.shorctut({
					keys: [
						['BACKSPACE'], // The backspace key on the keyboard
					],
					filters: [this.filterDesc('windowActive', ['Phasmophobia', 'Spelunky 2'])],
					varValues: {
						type: 'pirate',
					},
				}),
				this.trigger.voice({
					// ???,
					filters: [this.filterDesc('windowActive', ['Phasmophobia', 'Spelunky 2'])],
				}),
				this.trigger.channelReward({
					name: 'Catastrophe',
					filters: [this.filterDesc('isMod')],
				}),
			],
			triggerVariables: {
				type: {
					name: 'Adventure Type',
					description: 'Selected category of adventures to choose from (e.g. spooky, candy)',
					example: 'Wow, what a $type that was, people, eh?',
					default: 'spooky',
					expr: '$type',
				},
			},
			responseVariables: {
				winner: {
					name: 'Winner',
					description: 'Name of the user who won the adventure',
					example: 'Way to go $winner, you da man!',
				},
			},
			responses: [
				this.response.chat({
					message: 'Hello $user, nice to see you!',
				}),
				this.response.whisper({
					usernames: ['yecatsmailbox', '$user'],
					message: 'I saw you say that!',
				}),
				this.response.se({
					message: "Hi, I'm StreamElements!",
				}),
				this.response.tts({
					message: "Don't do that, $user!",
					voice: 'Brian',
				}),
				this.log({
					// Location? Category?
					message: '$user did that thing.',
				}),
				this.file({
					message: 'Yay $user!',
					append: false,  // True by default
				})
			],
		},
		
		saythis: {
			name: 'Say This',
			description: 'Makes the bot say the specified text',
			callback: params => this.say(params.msg),
			triggers: [
				this.trigger.command({
					cmdname: 'say',
					parameters: ['$...msg'],
				}),
			],
			inputVariables: {
				msg: {
					name: 'Message',
					description: 'The message the bot should say',
					expr: '$msg',
				},
			}
		},
		
		sayThis_UsingOnlyFunctionDefinition: {
			name: 'Say This - but without using a callback!',
			description: 'Makes the bot say the specified text',
			// NOT USING THIS --> callback: params => this.say(params.msg),
			triggers: [
				this.trigger.command({
					cmdname: 'say',
					parameters: ['$...msg'],
				}),
			],
			inputVariables: {
				msg: {
					name: 'Message',
					description: 'The message the bot should say',
					expr: '$msg',
				},
			},
			responses: [
				this.response.chat({
					message: '$msg',
				}),
			],
		},
	}
