+ Basic usage test (going to configure the server port)
+ Uniform configuration-supporting command registration for modules: I'm
  going to add a "commands" object to modules that will include all the
  information about the commands along with the callbacks for them. Then
  I'll link command registration to configuration loading.
+ UI for changing the configuration during runtime.
+ Configuration backup system
+ Add image floating (opposite of dropping), then add a random image pool to Catastrophe that floats up images randomly with keypresses and possible cooldown (e.g. no more than 1 image per 5 seconds).
+ Disable tab index on labels in GUI
+ Disable tab index on labels in modals
+ Default sizes for floating images (Catastrophe)
+ Remove value placeholders
- Hand icon for "selecting one(s)"
- Simpler mode
+ Duration still in milliseconds in image functions
+ Module descriptions
+ Changes marked in previously-accepted modules on any change
- GUI: Hitting Enter should switch to next field
+ Video assets
- Meme command that shows a random meme
- Testing =\
- Revamp configs to lessen descriptor count =\
- Remake configuration GUI x_x
	- Option 1:
		- Vue.js
		- Element-ui / Buefy
	- Option 2:
		- Vuetify
		- https://www.youtube.com/watch?v=nyJSd6V2DRI&list=PL55RiY5tL51p-YU-Uw90qQH419BM4Iz07
		- https://www.youtube.com/watch?v=2CSr2vBApSI&list=PL55RiY5tL51pT0DNJraU93FhMzhXxtDAo
		- https://www.youtube.com/watch?v=2uZYKcKHgU0&list=PL4cUxeGkcC9g0MQZfHwKcuB0Yswgb3gA5
- "status" CLI command that shows current connection status to everything
- Send keys to windows
X Function (probably triggered with key press) that switches a game source to use the window whose title matches the active window's title
+ Volume for image display
- Switch all duration configuration values from whatever number-type entity they are to DurationEntity
- Focus view: Transparent always-on-top window that only shows messages I'm tagged in. Possibly TTS for those as well, and/or sound alerts.

Module ideas:
- !random N => random number in [1, N]
- Trivia
	+ Exact match
	+ Show letters: _ _ _ _   _ _ for example
- Welcome: recognize person when raided/hosted by them.
- Death counters
- Send keys
	- Specify which keys, allow intervals between them
	- Each function should have filters for when it sends the keys (namely if a specific window is active, probably)
	- Common use case: timer trigger for a specified duration
		- E.g.: on Channel Point redemption, start sending the "T" key on random intervals if Phasmophobia is active
- Wheel
	+ Multiple wheels
	+ Define options
	- Title
	- Description:
		+ Streamer uses command to show the wheel
			+ Different command for each type of wheel
			+ Parameter for the user the spin is for
		+ Wheel image: tire on the outside, actual wheel inside it
			-> Background image behind the wheel, spin along with the wheel itself
		+ Show animation when the wheel shows up
		+ User uses command to spin the wheel at a random speed
		+ Optional: Show text of selected prize when the wheel stops
		+ Function for making the wheel disappear
		+ Fade out on disappear?
	+ Only one wheel active at a time
		- Using a command for a different wheel type overrides the current one
- Google Translate auto-mangle
	- Take the given sentence and run it through a chain of translations, then translate back to the original language and show that
	- Alternativel, translate each word separately like so ^
- Key cache + raffle
	- Allow for a multi-raffle, with an option for allowing repeating wins or not (different commands for it?)
	- Auto-replacement of duplicates
	- Manual gifting: random and specific
	- Whisper keys automatically on wins (OPTIONAL)
	- Announce the names of the keys people win
	- Modes:
		- Automatic random key
		- Randomize index order then get an index to the randomized list from the winner

GUI Library: Buefy
Twitch library: https://www.npmjs.com/package/twitch


GUI User Feedback:
+ Lables should be unmarkable, cursor should stay a pointer
- More text color to separate things from each other
- Accordions should allow only one thing open at a time
- Auto-complete user names from followers (fetch followers from Twitch)
- Hard to tell what you've done already, separate labels from folders, separate consecutive fields
- Cursor should highlight the entire row, not just the text

- Phasmophobia:
	- Guessing game:
		+ !guess / !ghost for ghost type guess
		- !room for room guess
		- !ev / !guessev for guessing evidence
	+ When found, the ghost type should show up as a stamp over the evidence (+ error stamp for bad evidence?)

- Support for user data files for modules (for large data that shouldn't
  be in the configurations themselves).
- Switch to function-trigger based configuration form.
  Trigger ideas:
	+ Command (with filters)
	- Keywords (+ filters, regex)
	- Twitch events (message, action, etc.)
	+ Key shortcut
	+ Key down/up
	- Controller buttons
	- Voice command
		- Microsoft STT
		- https://voiceattack.com/
	+ Channel Reward
	+ Window de/activation
	+ Window open/close
	- CLI command
	- Another function activating
	- Timer (random interval in range)
		- Start trigger (full Trigger option)
		- Two types: active for a duration and active until turned off
			- Duration:
				- Field for how long it is
				- When the start trigger is activated, adds the duration towards the time left
				- Possibly add an "Extendable" boolean option which allows the timer to be extended like that
			- Until turned off:
				- Trigger for turning it off
- Also add function responses.
  Response targets:
	+ Chat message
	- Whisper
	+ Chat message from SE
	- TTS
	+ Log
	- File?
  Response types:
	- Fixed text
	- Random from options
- Filter ideas:
	+ Specific user
	+ One of specific users
	+ Is mod
	+ Is sub
	+ And
	+ Or
	+ Window running
	+ Window active
	- Complex
	- Temporary window "switch"? (something switches it on - allowed, something switches it off - disallowed)
- Trigger variants
- Trigger export for modules (i.e. having the module adds triggers which the module itself would be responsible of triggering)
- "Not user" filter
+ Fix: single-time GIFs not starting over when shown again
- User data editor: raw (use shell to open Notepad for data files).
- User data editor: built-in, data-specific interface that allows visual
  editing of the data (each module will need to define these editors for
  itself).
- Persistent data for modules
+ OBS Websocket module
X Make WebEntities generation clear the WebEntities dir before writing to it.
- Generate commands information page to automatically be put online for viewers to see
- ZIP configuration text files
- Duration picker GUI for time-related values

- NPM Uninstall image-size if I no longer use it
+ Mark library directories as excluded in IDE after comitting, see if it does what I think it does

IDEAS!
- Bingo game
- Chat "Meow?": deletes all messages from people that aren't made of solely meowing.


Next:
+ Filters
+ Variables, help display, auto-complete variable names
	+ Make help text not close if focusing on that
+ Fix replacement with escaping so that using input text (written in a Twitch message by someone) on text replacements doesn't register as text to replace
- Switch everything to work with functions
- Phase out old code (commands, shortcuts, user filters if I do something completely different)
- Add more triggers and responses (see list above)
Then other things, probably in the following order:
- Add asset cleanup that gets rid of assets without linked configurations
	- Make that happen on configuration saves and startup
- Persistent data
- Complex data configuration (graphs for adventures, video for Channel Party, sequences for Parrot Mate)


Selected functions module setup example (what I'm acutally gonna do now):
	functions = {
		adventure: {
			name: 'Start Adventure',
			description: 'Starts the adventure by the user',
			parameters: [ // Order matters
				{
					name: 'Type', // Must be unique in the function
					description: 'The type of adventure to start (e.g. spooky, candy)',
					default: 'spooky',
					// Will have a .value filled in by the invocation
				}
			],
			callback: user => this.startRecruiting(user),
			cooldown: {
				user: 10,
				global: 5,
			},
			triggers: [
				this.trigger.command({
					cmdname: 'adventure',
					aliases: ['adv'],
					filters: [this.filterDesc('isOneOf', ['yecatsmailbox', 'fluxistence'])],
					cooldown: {
						user: 40,
						global: 20,
					},
				}),
				this.trigger.keywords({
					keywords: ['hello', 'there', /abc/],
					filters: [this.filterDesc('isOneOf', ['yecatsmailbox', 'fluxistence'])],
				}),
				this.trigger.shorctut({
					keys: [
						['BACKSPACE'], // The backspace key on the keyboard
					],
					filters: [this.filterDesc('windowActive', ['Phasmophobia', 'Spelunky 2'])],
					paramValues: [
						'candy',
					]
				}),
				this.trigger.voice({
					// ???,
					filters: [this.filterDesc('windowActive', ['Phasmophobia', 'Spelunky 2'])],
				}),
				this.trigger.channelReward({
					name: 'Catastrophe',
					filters: [this.filterDesc('isMod')],
				}),
			],
			variables: [
				this.variable.out('type', {
					name: 'Adventure Type ($type)',
					description: 'Selected category of adventures to choose from (e.g. spooky, candy)',
					example: 'Wow, what a $type that was, people, eh?',
				},
			],
			responses: [
				this.response.console('Hey, it worked!'),
				this.response.console({
					level: 'warn',
					message: 'Blame it on $user: 1: $1 2: $2 3: $3 all: $all.',
				}),
				this.response.chat({
					message: 'Hello $user, nice to see you! One $type adventure, coming up!',
				}),
				this.response.whisper({
					usernames: ['yecatsmailbox', '$user'],
					message: 'I saw you say that!',
				}),
				this.response.se({
					message: "Hi, I'm StreamElements!",
				}),
				this.response.tts({
					message: "Don't do that, $user!",
					voice: 'Brian',
				}),
				this.log({
					// Location? Category?
					message: '$user did that thing.',
				}),
				this.file({
					message: 'Yay $user!',
					path: 'C:/Path/to/file.txt',
					append: false,  // True by default
				})
			],
		},
	}





Potential functions module setup example (NOTE: all trigger variables are available as response variables automatically):
	functions = {
		adventure: {
			name: 'Start Adventure',
			description: 'Starts the adventure by the user',
			callback: user => this.startRecruiting(user),
			cooldown: {
				user: 10,
				global: 5,
			},
			triggers: [
				this.trigger.command({
					cmdname: 'adventure',
					aliases: ['adv'],
					filters: [this.filterDesc('isOneOf', ['yecatsmailbox', 'fluxistence'])],
					cooldown: {
						user: 40,
						global: 20,
					},
					parameters: ['$type'],
				}),
				this.trigger.keywords({
					keywords: ['hello', 'there', /abc/],
					filters: [this.filterDesc('isOneOf', ['yecatsmailbox', 'fluxistence'])],
				}),
				this.trigger.shorctut({
					keys: [
						['BACKSPACE'], // The backspace key on the keyboard
					],
					filters: [this.filterDesc('windowActive', ['Phasmophobia', 'Spelunky 2'])],
					varValues: {
						type: 'pirate',
					},
				}),
				this.trigger.voice({
					// ???,
					filters: [this.filterDesc('windowActive', ['Phasmophobia', 'Spelunky 2'])],
				}),
				this.trigger.channelReward({
					name: 'Catastrophe',
					filters: [this.filterDesc('isMod')],
				}),
			],
			triggerVariables: {
				type: {
					name: 'Adventure Type',
					description: 'Selected category of adventures to choose from (e.g. spooky, candy)',
					example: 'Wow, what a $type that was, people, eh?',
					default: 'spooky',
					expr: '$type',
				},
			},
			responseVariables: {
				winner: {
					name: 'Winner',
					description: 'Name of the user who won the adventure',
					example: 'Way to go $winner, you da man!',
				},
			},
			responses: [
				this.response.chat({
					message: 'Hello $user, nice to see you!',
				}),
				this.response.whisper({
					usernames: ['yecatsmailbox', '$user'],
					message: 'I saw you say that!',
				}),
				this.response.se({
					message: "Hi, I'm StreamElements!",
				}),
				this.response.tts({
					message: "Don't do that, $user!",
					voice: 'Brian',
				}),
				this.log({
					// Location? Category?
					message: '$user did that thing.',
				}),
				this.file({
					message: 'Yay $user!',
					append: false,  // True by default
				})
			],
		},
		
		saythis: {
			name: 'Say This',
			description: 'Makes the bot say the specified text',
			callback: params => this.say(params.msg),
			triggers: [
				this.trigger.command({
					cmdname: 'say',
					parameters: ['$...msg'],
				}),
			],
			inputVariables: {
				msg: {
					name: 'Message',
					description: 'The message the bot should say',
					expr: '$msg',
				},
			}
		},
		
		sayThis_UsingOnlyFunctionDefinition: {
			name: 'Say This - but without using a callback!',
			description: 'Makes the bot say the specified text',
			// NOT USING THIS --> callback: params => this.say(params.msg),
			triggers: [
				this.trigger.command({
					cmdname: 'say',
					parameters: ['$...msg'],
				}),
			],
			inputVariables: {
				msg: {
					name: 'Message',
					description: 'The message the bot should say',
					expr: '$msg',
				},
			},
			responses: [
				this.response.chat({
					message: '$msg',
				}),
			],
		},
	}







GUI Design
- Groups in tabs
- Make unwanted modules disappear (filtering: name / enabled)
- Compact view:
	- Show basic details
	- Show extra details iff they have data
	- Button to add extra detail (which currently has no data)
- Image Functions:
	- For an image command, show the command and the image
	- For functions with other triggers, specialized views for single-trigger functions that show the trigger and image
	- If multiple triggers are present, use the first one as the primary type








