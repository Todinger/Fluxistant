+ Basic usage test (going to configure the server port)
+ Uniform configuration-supporting command registration for modules: I'm
  going to add a "commands" object to modules that will include all the
  information about the commands along with the callbacks for them. Then
  I'll link command registration to configuration loading.
+ UI for changing the configuration during runtime.
+ Configuration backup system
- Support for user data files for modules (for large data that shouldn't
  be in the configurations themselves).
- Switch to function-trigger based configuration form.
  Trigger ideas:
	- Command (with filters)
	- Keywords (+ filters, regex)
	- Twitch events (message, action, etc.)
	- Key shortcut
	- Key down/up
	- Controller buttons
	- Voice command
	- Channel Reward
	- Window de/activation
	- Window open/close
	- CLI command
- Also add function responses.
  Response ideas:
	- Chat message
	- Whisper
	- Chat message from SE
	- TTS
	- Log
	- File?
- Trigger variants
- "Not user" filter
- Fix: single-time GIFs not starting over when shown again
- User data editor: raw (use shell to open Notepad for data files).
- User data editor: built-in, data-specific interface that allows visual
  editing of the data (each module will need to define these editors for
  itself).
- Persistent data for modules
- OBS Websocket module
- Voice activation mechanism (in addition to commands and shortcut keys)

- NPM Uninstall image-size if I no longer use it


IDEAS!
- Bingo game
- Chat "Meow?": deletes all messages from people that aren't made of solely meowing.



Functions module setup example (NOTE: all trigger variables are available as response variables automatically):
	functions = {
		adventure: {
			name: 'Start Adventure',
			description: 'Starts the adventure by the user',
			callback: user => this.startRecruiting(user),
			cooldown: {
				user: 10,
				global: 5,
			},
			triggers: [
				this.trigger.command({
					cmdname: 'adventure',
					aliases: ['adv'],
					filters: [this.filterDesc('isOneOf', ['yecatsmailbox', 'fluxistence'])],
					cooldown: {
						user: 40,
						global: 20,
					},
					parameters: ['$type'],
				}),
				this.trigger.keywords({
					keywords: ['hello', 'there', /abc/],
					filters: [this.filterDesc('isOneOf', ['yecatsmailbox', 'fluxistence'])],
				}),
				this.trigger.shorctut({
					keys: [
						['BACKSPACE'], // The backspace key on the keyboard
					],
					filters: [this.filterDesc('windowActive', ['Phasmophobia', 'Spelunky 2'])],
					varValues: {
						type: 'pirate',
					},
				}),
				this.trigger.voice({
					// ???,
					filters: [this.filterDesc('windowActive', ['Phasmophobia', 'Spelunky 2'])],
				}),
				this.trigger.channelReward({
					name: 'Catastrophe',
					filters: [this.filterDesc('isMod')],
				}),
			],
			triggerVariables: {
				type: {
					name: 'Adventure Type',
					description: 'Selected category of adventures to choose from (e.g. spooky, candy)',
					example: 'Wow, what a $type that was, people, eh?',
					default: 'spooky',
					expr: '$type',
				},
			},
			responseVariables: {
				winner: {
					name: 'Winner',
					description: 'Name of the user who won the adventure',
					example: 'Way to go $winner, you da man!',
				},
			},
			responses: [
				this.response.chat({
					message: 'Hello $user, nice to see you!',
				}),
				this.response.whisper({
					usernames: ['yecatsmailbox', '$user'],
					message: 'I saw you say that!',
				}),
				this.response.se({
					message: "Hi, I'm StreamElements!",
				}),
				this.response.tts({
					message: "Don't do that, $user!",
					voice: 'Brian',
				}),
				this.log({
					// Location? Category?
					message: '$user did that thing.',
				}),
				this.file({
					message: 'Yay $user!',
					append: false,  // True by default
				})
			],
		},
		
		saythis: {
			name: 'Say This',
			description: 'Makes the bot say the specified text',
			callback: params => this.say(params.msg),
			triggers: [
				this.trigger.command({
					cmdname: 'say',
					parameters: ['$...msg'],
				}),
			],
			inputVariables: {
				msg: {
					name: 'Message',
					description: 'The message the bot should say',
					expr: '$msg',
				},
			}
		},
		
		sayThis_UsingOnlyFunctionDefinition: {
			name: 'Say This - but without using a callback!',
			description: 'Makes the bot say the specified text',
			// NOT USING THIS --> callback: params => this.say(params.msg),
			triggers: [
				this.trigger.command({
					cmdname: 'say',
					parameters: ['$...msg'],
				}),
			],
			inputVariables: {
				msg: {
					name: 'Message',
					description: 'The message the bot should say',
					expr: '$msg',
				},
			},
			responses: [
				this.response.chat({
					message: '$msg',
				}),
			],
		},
	}
